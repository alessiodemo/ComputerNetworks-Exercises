/*
Modify the ping.c program to implement the basic functions of the IP node, so that it is able to recognize, in reception, as well as the usual ICMP "message echo reply", also another type of ICMP message, called "unreachable destination" for which the documentation from RFC 792 is reported. 

Note that the "message unreachable destination" is generated by a router on the network, in the event that it detects that the IP datagram that is forwarding is intended for an address that can never be reached. In this case the router: 
delete that IP packet (i.e. do not forward it to any other router). 
create ICMP message "unreachable destination" 
sends the ICMP message to the node that generated the IP packet without destination reachable to warn that it has deleted the packet. 

Try to receive as many different type (“codes”) in reply by sending appropriate packets in the network (ICMP/IP or TCP/IP).

*/


#include<stdio.h>
#include <net/if.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <linux/if_packet.h>
#include <net/ethernet.h>
#include <errno.h>
#include <string.h>  // [MODIFIED] for memset

// Structures remain unchanged

struct arp_packet {
    unsigned short htype;
    unsigned short ptype;
    unsigned char hlen;
    unsigned char plen;
    unsigned short op;
    unsigned char srcmac[6];
    unsigned char srcip[4];
    unsigned char dstmac[6];
    unsigned char dstip[4];
};

struct eth_frame {
    unsigned char dst[6];
    unsigned char src[6];
    unsigned short type;
    unsigned char payload[1];
};

struct ip_datagram {
    unsigned char ver_ihl;
    unsigned char tos;
    unsigned short totlen;
    unsigned short id;
    unsigned short flags_offs;
    unsigned char ttl;
    unsigned char proto;
    unsigned short checksum;
    unsigned int src;
    unsigned int dst;
    unsigned char payload[1];
};

struct icmp_packet {
    unsigned char type;
    unsigned char code;
    unsigned short checksum;
    unsigned short id;
    unsigned short seq;
    unsigned char payload[1];
};

unsigned char myip[4] = {212, 71, 252, 26};
unsigned char mymac[6] = {0xF2, 0x3C, 0x94, 0x90, 0x4F, 0x4b};
unsigned char gateway[4] = {212, 71, 252, 1};
unsigned char mask[4] = {255, 255, 255, 0};
unsigned char target_ip[4] = {147, 162, 2, 100};
unsigned char broadcast[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
int s;

int resolve_ip(unsigned char *target, unsigned char *mac);
void print_buffer(unsigned char* buffer, int size);

unsigned short checksum(unsigned char *b, int len) {
    unsigned short *p = (unsigned short *)b;
    unsigned int tot = 0;
    int i;
    for (i = 0; i < len / 2; i++) {
        tot += ntohs(p[i]);
        if (tot & 0x10000) tot = (tot + 1) & 0xFFFF;
    }
    if (len & 0x1) {
        tot += ntohs(p[i]) & 0xFF00;
        if (tot & 0x10000) tot = (tot + 1) & 0xFFFF;
    }
    return (0xFFFF - ((unsigned short)tot));
}

void forge_icmp(struct icmp_packet *icmp, unsigned char type, unsigned char code, int payloadsize) {
    icmp->type = type;
    icmp->code = code;
    icmp->checksum = 0;
    icmp->id = htons(0xABCD);
    icmp->seq = htons(1);
    for (int i = 0; i < payloadsize; i++)
        icmp->payload[i] = i;
    icmp->checksum = htons(checksum((unsigned char*)icmp, payloadsize + 8));
}

void forge_ip(struct ip_datagram *ip, unsigned short payloadlen, unsigned char *dst) {
    ip->ver_ihl = 0x45;
    ip->tos = 0;
    ip->totlen = htons(payloadlen + 20);
    ip->id = htons(0x1234);
    ip->flags_offs = htons(0);
    ip->ttl = 128;
    ip->proto = 1;
    ip->checksum = 0;
    ip->src = *((unsigned int *)myip);
    ip->dst = *((unsigned int *)dst);
    ip->checksum = htons(checksum((unsigned char *)ip, 20));
}

void print_buffer(unsigned char* buffer, int size) {
    for (int i = 0; i < size; i++) {
        printf("%.3d (%.2X) ", buffer[i], buffer[i]);
        if (i % 4 == 3) printf("\n");
    }
    printf("\n");
}

int resolve_ip(unsigned char *target, unsigned char *mac) {
    int len;
    unsigned char buffer[1500];
    struct sockaddr_ll sll;
    struct arp_packet *arp;
    struct eth_frame *eth;
    int i, j, n;

    eth = (struct eth_frame *) buffer;
    arp = (struct arp_packet *) eth->payload;

    for (i = 0; i < 6; i++) {
        eth->src[i] = mymac[i];
        eth->dst[i] = 0xFF;
    }
    eth->type = htons(0x0806);

    arp->htype = htons(1);
    arp->ptype = htons(0x0800);
    arp->hlen = 6;
    arp->plen = 4;
    arp->op = htons(1);

    for (i = 0; i < 6; i++) {
        arp->srcmac[i] = mymac[i];
        arp->dstmac[i] = 0;
    }
    for (i = 0; i < 4; i++) {
        arp->srcip[i] = myip[i];
        arp->dstip[i] = target[i];
    }

    memset(&sll, 0, sizeof(struct sockaddr_ll));
    sll.sll_family = AF_PACKET;
    sll.sll_ifindex = if_nametoindex("eth0");
    len = sizeof(struct sockaddr_ll);

    if (-1 == sendto(s, buffer, 1500, 0, (struct sockaddr *) &sll, len)) {
        perror("Send Failed");
        return 1;
    }

    j = 100;
    while (j--) {
        n = recvfrom(s, buffer, 1500, 0, (struct sockaddr *) &sll, &len);
        if (n == -1) {
            perror("Recvfrom Failed");
            return 1;
        }

        if (eth->type == htons(0x0806) && arp->op == htons(2)) {
            printf("ARP REPLY RECEIVED:\n");
            print_buffer(buffer, n);
            for (i = 0; i < 6; i++)
                mac[i] = arp->srcmac[i];
            return 0;
        }
    }

    return 1;
}

int main() {
    unsigned char buffer[1500];
    struct icmp_packet *icmp;
    struct ip_datagram *ip;
    struct eth_frame *eth;
    struct sockaddr_ll sll;
    int len, n, i, j;
    unsigned char target_mac[6];

    s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if (s == -1) {
        perror("Socket Failed");
        return 1;
    }

    eth = (struct eth_frame *) buffer;
    ip = (struct ip_datagram *) eth->payload;
    icmp = (struct icmp_packet *) ip->payload;

    forge_icmp(icmp, 8, 0, 40);
    forge_ip(ip, 48, target_ip);

    if ((*(unsigned int *)myip & *(unsigned int *)mask) ==
        (*(unsigned int *)target_ip & *(unsigned int *)mask)) {
        if (resolve_ip(target_ip, target_mac)) printf("Resolution Failed\n");
    } else {
        if (resolve_ip(gateway, target_mac)) printf("Resolution Failed\n");
    }

    for (i = 0; i < 6; i++) {
        eth->dst[i] = target_mac[i];
        eth->src[i] = mymac[i];
    }
    eth->type = htons(0x0800);

    printf("Ethernet header\n");
    print_buffer((unsigned char *)eth, 14);
    printf("Ethernet payload\n");
    print_buffer((unsigned char *)ip, 68);

    memset(&sll, 0, sizeof(struct sockaddr_ll));
    sll.sll_family = AF_PACKET;
    sll.sll_ifindex = if_nametoindex("eth0");
    len = sizeof(struct sockaddr_ll);

    if (-1 == sendto(s, buffer, 1500, 0, (struct sockaddr *)&sll, len)) {
        perror("Send Failed");
        return 1;
    }

    j = 100;
    while (j--) {
        n = recvfrom(s, buffer, 1500, 0, (struct sockaddr *)&sll, &len);
        if (n == -1) {
            perror("Recvfrom Failed");
            return 1;
        }

        if (eth->type == htons(0x0800) && ip->proto == 1) { // IP and ICMP
            printf("ICMP PKT RECEIVED:\n");
        
            if (icmp->type == 0 && icmp->id == htons(0xABCD)) {
                printf("ICMP ECHO REPLY DETECTED\n");
                print_buffer((unsigned char *)ip, 20 + 48);
                break;
        
                //[MODIFIED]
            } else if (icmp->type == 3) {  // Destination Unreachable
                printf("ICMP DESTINATION UNREACHABLE RECEIVED\n");
                printf(" - Code: %d\n", icmp->code);
                switch (icmp->code) {
                    case 0: printf(" - Net Unreachable\n"); break;
                    case 1: printf(" - Host Unreachable\n"); break;
                    case 2: printf(" - Protocol Unreachable\n"); break;
                    case 3: printf(" - Port Unreachable\n"); break;
                    case 4: printf(" - Fragmentation Needed and DF set\n"); break;
                    case 5: printf(" - Source Route Failed\n"); break;
                    default: printf(" - Other Code: %d\n", icmp->code); break;
                }
                print_buffer((unsigned char *)ip, n);
                // Not breaking here so we can continue listening for valid replies
            }
        }
        
    }

    return 0;
}


/*
Summary of Additions:

    ✔ Defined a generic icmp_generic struct.

    ✔ Extended packet inspection logic in main() to recognize and interpret type 3 messages.

    ✔ Printed detailed info on unreachable code meanings.

    ✔ Preserved echo reply functionality.
*/